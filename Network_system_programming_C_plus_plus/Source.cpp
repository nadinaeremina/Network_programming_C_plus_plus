// 'Windsoe' - интерфейс, предназначенный для работы с сокетами в С++
// Оборачивает протоколы, которые выполняют передачу инф-ции, 
// то представляет собой некий интерфейс между процессом и протоколом

#include "WinSock2.h" // биб-ка для р-ты с сокетами
#pragma comment(lib, "Ws2_32.lib")
// 'pragma comment' - команда для того, чтобы подключить ее как конкретную библиотеку
// реализует биб-ку 'WindowsSocket'
#include <WS2tcpip.h> // для 'inet_pton'

void main()
{
    WSAData wd;
    if (WSAStartup(MAKEWORD(2, 2), &wd) == 0); // вызываем эту ф-цию, чтобы иметь доступ к интерфейсу WinSocket
    // 1-ый арг-т: спец. слово, кот. состоит из двух байт (первый определяет версию, второй - подверсию)
    // 2-ой арг-т: указатель на стр-ру типа 'WSAData', 
    // кот. в рез-те р-ты ф-ции будет получать инф-цию о реализации текущей версии Windows socket
    // если все пройдет благополучно 'WSAStartup' вернет 0 - в противном случае код ошибки
    {
        SOCKET dsocket = socket(AF_INET, SOCK_STREAM, 0); // его нужно ассоциировать с адресом и портом
        // название дескриптора должно отличаться от названия ф-ции, 
        // потому что само слово 'socket' - ф-ция, которая конструирует дискриптор

        // 1 // в ф-цию передаем int (но мы не пишем число вручную - для этого есть константы)
        // чаще всего исп-ся 'AF_INET'(в с#-API4)  и 'AF_INET6' - это просто константы, опред. протокол IP

        // 2 // аргумент 'type' - определяет тип создаваемого сокета (как в С# - 'Stream'/'DGram')

        // 3 // номер для протокола (TCP/UDP) 
        // если указать - 0 - используемый протокол выбирается поставщиком услуг - автоматически

        char* a = new char[256]; // указатель на буфер
        setsockopt(dsocket, 1, SO_DEBUG, a, 256); // ф-ция для настройки сокета
        // 1) дискриптор того сокета, с которым будет работать
        // 2) уровень протокола, на котором задается пар-р сокета
        // 3) название сокета
        // 4) указатель на буфер, в котором стоит значение
        // 5) размер буфера байта

        // если ф-ци вып-ся корректно - вернет 0

        sockaddr_in sa;
        sa.sin_family = AF_INET; // у стр-ры можно указать также семейство типов

        // получаем семейство с помощью след.ф-ции
        inet_pton(AF_INET, "127.0.0.1", &sa.sin_addr); // можно преобразовать строку символов в стр-ру символов сетевого адреса
        // 1) семейство типов
        // 2) строчка с адресом, которую мы преобразуем
        // 3) указатель на адрес, куда мы помещаем рез-т обработки этой стр-ры

        // биндинг обычно необходим на стороне сервера, на клиенте можно делать,
        // но в стандартной реализации у нас есть ф-ция 'connect',
        // которая биндит сокет к адресу хоста через случайный порт
        bind(dsocket, (SOCKADDR*)&sa, sizeof(sa));
        // 1) дискриптор сокета
        // 2) указатель на стр-ру 'sockaddr' (она позволяет хранить инф-цию в семействе адреса,
        // ip-адрес и порт
        // 3) длина этой стр-ры

        // 'Listen' - установит сокет в режим прослушивания входящих соединений
        if (listen(dsocket, 1) == 0); // если все хорошо - вернет 0
        // 1) дискриптор сокета
        // 2) максимальный размер очереди входящих подключений 
        // (также как в C# у 'Listen' передавались данные, сколько может быть входящих подключений)
        {
            // создаем стр-ру и передаем на нее указатель, чтобы получить инф-цию о пользователе
            // адресе подкл. сокета
            sockaddr csa;

            // когда сокет прослушивает - ему нужно принять входящие соед-ия с пом ф-ции 'accept'
            // она возвращает сокет клиента, который подключается    
            // последние 2 пар-ра необязательны, можно передать 'nullptr'

            // SOCKET in_dsock = accept(dsocket, &csa, sizeof(&csa));
            SOCKET in_dsock = accept(dsocket, nullptr, nullptr);
            // если с ф-цией все хорошо - она возвращает дискриптор нового созданного сокета
            // она блокируется
            // если в очереди нет клиентов на подключение - то ф-ция ждет, пока кто-нибудь не подключится
            // если нужно обработать несколько клиентов - 

            // 'connect' - для соед-ия сокета // необязателен, если исп-ем DGRAM
            if (connect(dsocket, &csa, sizeof(csa)) == 0); // если успешно - вернет - 0
            // 1) адрес сокета
            // 2) указатель на сок 'sockaddr'
            // 3) и его длину
            {
                // send/receive - отправить или получить инф-цию по TCP
                // sendTO/ReceiveFrom - отправить или получить инф-цию по UDP

                closesocket(dsocket); // для завершения работы с сокетом
            }
        }
    }
}
